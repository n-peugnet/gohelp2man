// gohelp2man, generate a man page out of a Go program's -help output
//
// Copyright (C) 2025  Nicolas Peugnet <nicolas@club1.fr>
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, see <https://www.gnu.org/licenses/>.

//go:generate go build
//go:generate go tool gohelp2man -include=gohelp2man.h2m -output=gohelp2man.1 ./gohelp2man

package main

import (
	"bufio"
	"bytes"
	"flag"
	"fmt"
	"io"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"runtime/debug"
	"strconv"
	"strings"
	"time"
)

const (
	Name  = "gohelp2man"
	Usage = `%s generates a man page out of a Go program's -help output.

Go has a simple but very effective "flag" package that can be used to quickly
create CLI applications without any additional dependencies. But this package
cannot generate man pages.

gohelp2man takes inspiration from GNU help2man, and generates a man page from
the -help output of your Go program. It is specifically designed to recognise
the help message generated by the "flag" package.

It is a great match with "go get -tool" and "go generate"!

Usage: %s [OPTION]... EXECUTABLE
`

	RegexSection = `^\[([^]]+)\]\s*$`
	RegexUsage   = `[Uu]sage(:| of) (?U:(.*)):?$`
	RegexHeader  = `^(\w.*):\s*$`
	RegexFlag    = `^  -((\w)\t(.*)|([-\w]+) (.+)|[-\w]+)$`
)

var (
	l            = log.New(os.Stderr, Name+": ", 0)
	regexSection = regexp.MustCompile(RegexSection)
	regexUsage   = regexp.MustCompile(RegexUsage)
	regexHeader  = regexp.MustCompile(RegexHeader)
	regexFlag    = regexp.MustCompile(RegexFlag)
)

var KnownSections = [12]string{
	"NAME",
	"SYNOPSIS",
	"DESCRIPTION",
	"OPTIONS",
	// Other
	"ENVIRONMENT",
	"FILES",
	"EXAMPLES",
	"AUTHOR",
	"REPORTING BUGS",
	"COPYRIGHT",
	"SEE ALSO",
}

func findKnownSection(s string) (title string, found bool) {
	title = strings.ToUpper(s)
	switch title {
	case "OPTIONS", "FLAGS":
		title = "OPTIONS"
		fallthrough
	case "NAME",
		"SYNOPSIS",
		"DESCRIPTION",
		"ENVIRONMENT",
		"FILES",
		"EXAMPLES",
		"AUTHOR",
		"REPORTING BUGS",
		"COPYRIGHT",
		"SEE ALSO":
		found = true
	}
	return
}

type Section struct {
	Title string
	Text  string
}

type Flag struct {
	Name  string
	Arg   string
	Usage string
}

func (f *Flag) String() string {
	return fmt.Sprintf("-%s %q: %s", f.Name, f.Arg, f.Usage)
}

type Help struct {
	Usage       string
	Description string
	Flags       []*Flag
	Sections    map[string]*Section

	scanner *bufio.Scanner
}

func NewHelp(help io.Reader) *Help {
	return &Help{
		Sections: make(map[string]*Section),
		scanner:  bufio.NewScanner(help),
	}
}

func (h *Help) parseUsage() (usage string, found bool) {
	line := h.scanner.Text()
	m := regexUsage.FindStringSubmatch(line)
	if m != nil {
		return m[2], true
	}
	return "", false
}

func (h *Help) parseHeader() (header string, found bool) {
	line := h.scanner.Text()
	m := regexHeader.FindStringSubmatch(line)
	if m != nil {
		return m[1], true
	}
	return "", false
}

func (h *Help) parseFlag() (f *Flag, found bool) {
	line := h.scanner.Text()
	m := regexFlag.FindStringSubmatch(line)
	found = m != nil
	if found {
		f = new(Flag)
		switch {
		case m[2] != "":
			f.Name = m[2]
			f.Usage = m[3]
			return
		case m[4] != "":
			f.Name = m[4]
			f.Arg = m[5]
		default:
			f.Name = m[1]
		}
		if !h.scanner.Scan() {
			panic("missing description for long flag: " + f.Name)
		}
		f.Usage = strings.TrimSpace(h.scanner.Text())
	}
	return
}

func (h *Help) parse() error {
	var s *Section
	var text strings.Builder
	finaliseSection := func() {
		if s != nil {
			s.Text = strings.TrimSpace(text.String())
		} else {
			h.Description = strings.TrimSpace(text.String())
		}
		text.Reset()
	}

	for h.scanner.Scan() {
		if u, found := h.parseUsage(); found {
			h.Usage = u
			// TODO: scan lines until they do not look like usage lines
			continue
		}
		if hr, found := h.parseHeader(); found {
			if title, found := findKnownSection(hr); found {
				finaliseSection()
				s = &Section{Title: hr}
				h.Sections[title] = s
			} else {
				text.WriteString(".SS ")
				text.WriteString(hr)
				text.WriteString(":\n")
			}
			continue
		}
		if f, found := h.parseFlag(); found {
			h.Flags = append(h.Flags, f)
			// TODO: scan lines until they do not look like flag descriptions
			continue
		}
		text.Write(h.scanner.Bytes())
		text.WriteString("\n")
	}
	finaliseSection()
	return h.scanner.Err()
}

type Include struct {
	Name          string
	Description   string
	Sections      map[string]*Section
	OtherSections []*Section
}

func parseInclude(path string) (*Include, error) {
	i := &Include{Sections: make(map[string]*Section)}
	file, err := os.Open(path)
	if err != nil {
		return nil, err
	}

	var s *Section
	var text strings.Builder
	finaliseSection := func() {
		if s != nil {
			s.Text = strings.TrimSpace(text.String())
			if title, found := findKnownSection(s.Title); found {
				i.Sections[title] = s
			} else {
				i.OtherSections = append(i.OtherSections, s)
			}
		}
		text.Reset()
	}

	scanner := bufio.NewScanner(bufio.NewReader(file))
	for scanner.Scan() {
		line := scanner.Text()
		m := regexSection.FindStringSubmatch(line)
		if m != nil {
			finaliseSection()
			s = &Section{Title: m[1]}
			continue
		}
		text.WriteString(line)
		text.WriteString("\n")
	}
	finaliseSection()
	return i, scanner.Err()
}

func getHelp(exe string) ([]byte, error) {
	cmd := exec.Command(exe, "-help")
	out, err := cmd.CombinedOutput()
	if err != nil {
		return nil, fmt.Errorf("run %s: %w", cmd, err)
	}
	if len(out) == 0 {
		return nil, fmt.Errorf("run %s: empty output", cmd)
	}
	return out, err
}

func now() time.Time {
	if epoch := os.Getenv("SOURCE_DATE_EPOCH"); epoch != "" {
		unixEpoch, err := strconv.ParseInt(epoch, 10, 64)
		if err != nil {
			panic("invalid SOURCE_DATE_EPOCH: " + err.Error())
		}
		return time.Unix(unixEpoch, 0)
	} else {
		return time.Now()
	}
}

var escapeReplacer = strings.NewReplacer(
	`-`, `\-`,
	`\`, `\(rs`,
	"\n\n", "\n.PP\n", // TODO: make this more robust
)

func e(v any) string {
	return escapeReplacer.Replace(fmt.Sprint(v))
}

func efprint(w io.Writer, args ...any) (int, error) {
	return escapeReplacer.WriteString(w, fmt.Sprint(args...))
}

func efprintln(w io.Writer, args ...any) (int, error) {
	return escapeReplacer.WriteString(w, fmt.Sprintln(args...))
}

func efprintf(w io.Writer, format string, args ...any) (int, error) {
	eargs := make([]any, len(args))
	for i, arg := range args {
		eargs[i] = e(arg)
	}
	return fmt.Fprintf(w, format, eargs...)
}

// writeSynopsis formats a synopsis line by writing the command name in bold
// and the arguments inside brackets in italic.
func writeSynopsis(w io.Writer, synopsis string) {
	name, args, found := strings.Cut(strings.TrimSpace(synopsis), " ")
	efprintf(w, "\\fB%s\\fR", name)
	if found {
		fmt.Fprint(w, " ")
	}
	for {
		lBracket := strings.Index(args, "[")
		if lBracket == -1 {
			efprint(w, args)
			break
		}
		efprint(w, args[:lBracket])
		args = args[lBracket:]
		rBracket := strings.Index(args, "]")
		if rBracket == -1 {
			efprint(w, args)
			break
		}
		fmt.Fprint(w, "[")
		efprintf(w, "\\fI%s\\fR", args[1:rBracket])
		fmt.Fprint(w, "]")
		args = args[rBracket+1:]
	}
	fmt.Fprintln(w)
}

func main() {
	cli := flag.NewFlagSet(Name, flag.ExitOnError)
	cli.Usage = func() {
		fmt.Fprintf(cli.Output(), Usage, Name, Name)
		cli.PrintDefaults()
	}
	var (
		flagHelp    bool
		flagInclude string
		flagName    string
		flagOutput  string
		flagSection uint
		flagVersion bool
	)
	cli.BoolVar(&flagHelp, "help", false, "Show this help and exit.")
	cli.StringVar(&flagInclude, "include", "", "Include material from `FILE`.")
	cli.StringVar(&flagName, "name", "", "Description for the NAME paragraph.")
	cli.StringVar(&flagOutput, "output", "", "Send output to `FILE` rather than stdout.")
	cli.UintVar(&flagSection, "section", 1, "Section number for manual page (1, 6, 8).")
	cli.BoolVar(&flagVersion, "version", false, "Show version number and exit.")
	cli.Parse(os.Args[1:])

	if flagHelp {
		cli.Usage()
		os.Exit(0)
	}

	if flagVersion {
		v := "(unknown)"
		info, ok := debug.ReadBuildInfo()
		if ok {
			v = info.Main.Version
		}
		fmt.Println(Name, v)
		os.Exit(0)
	}

	exe := cli.Arg(0)
	if exe == "" {
		l.Print("missing argument: executable")
		cli.Usage()
		os.Exit(2)
	}

	include := &Include{}
	if flagInclude != "" {
		var err error
		include, err = parseInclude(flagInclude)
		if err != nil {
			l.Fatalln("parse include:", err)
		}
	}

	out, err := getHelp(exe)
	if err != nil {
		l.Fatalln("get help:", err)
	}
	help := NewHelp(bytes.NewBuffer(out))
	err = help.parse()
	if err != nil {
		l.Fatalln("parse output:", err)
	}

	name := filepath.Base(exe)
	description := "manual page for " + name
	if s, found := include.Sections["NAME"]; found {
		n, d, ok := strings.Cut(s.Text, " - ")
		if !ok {
			l.Fatalf("invalid [name] section %q", s.Text)
		}
		if i := strings.IndexAny(n, " \t\n\r"); i != -1 {
			l.Fatalf("illegal character %q in program name: %q", n[i], n)
		}
		name, description = n, d
	}
	if flagName != "" {
		description = flagName
	}

	var w io.Writer
	if flagOutput != "" {
		file, err := os.Create(flagOutput)
		if err != nil {
			l.Fatalln("create output file:", err)
		}
		w = bufio.NewWriter(file)
	} else {
		w = os.Stdout
	}
	b := bufio.NewWriter(w)

	// Write generator comment
	fmt.Fprintf(b, `.\" Generated by %s`, Name)
	cli.Visit(func(f *flag.Flag) {
		if f.Name != "output" {
			fmt.Fprintf(b, " -%s %v", f.Name, f.Value)
		}
	})
	fmt.Fprintf(b, " %s; DO NOT EDIT.\n", strings.Join(cli.Args(), " "))

	// Write title
	fmt.Fprintf(b, ".TH %s %v %q %q\n",
		e(strings.ToUpper(name)), flagSection, now().Format("2006-01-02"), name,
	)

	// Write NAME section
	efprintf(b, ".SH NAME\n%v \\- %v\n", name, description)

	// Write SYNOPSIS section
	fmt.Fprintln(b, ".SH SYNOPSIS")
	if s, found := include.Sections["SYNOPSIS"]; found {
		fmt.Fprintln(b, s.Text)
	} else if help.Usage != "" {
		writeSynopsis(b, help.Usage)
	} else {
		efprintf(b, "\\fB%s\\fR [\\fIOPTION\\fR]... [\\fIARGUMENT\\fR]...\n", name)
	}

	// Write DESCRIPTION section
	if s, found := include.Sections["DESCRIPTION"]; found {
		fmt.Fprintln(b, s.Text)
	}
	if help.Description != "" {
		efprintf(b, ".SH DESCRIPTION\n%s\n", help.Description)
	}

	// Write OPTIONS section
	fmt.Fprint(b, ".SH OPTIONS\n")
	if s, found := include.Sections["OPTIONS"]; found {
		fmt.Fprintln(b, s.Text)
	}
	if s, found := help.Sections["OPTIONS"]; found {
		efprintln(b, s.Text)
	}
	for _, f := range help.Flags {
		if f.Arg != "" {
			efprintf(b, ".TP\n\\fB\\-%s\\fR %s\n", f.Name, f.Arg)
		} else {
			efprintf(b, ".TP\n\\fB\\-%s\\fR\n", f.Name)
		}
		efprintln(b, f.Usage)
	}

	// Write other included sections
	for _, s := range include.OtherSections {
		fmt.Fprintf(b, ".SH %s\n%s\n", s.Title, s.Text)
	}

	// Write last known sections
	for _, title := range KnownSections[4:] {
		if s, found := include.Sections[title]; found {
			fmt.Fprintf(b, ".SH %s\n%s\n", s.Title, s.Text)
		}
		if s, found := help.Sections[title]; found {
			efprintf(b, ".SH %s\n%s\n", s.Title, s.Text)
		}
	}

	// Print man page
	b.Flush()
}
