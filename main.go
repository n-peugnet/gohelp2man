// gohelp2man, generate a man page out of a Go program's -help output
//
// Copyright (C) 2025  Nicolas Peugnet <nicolas@club1.fr>
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, see <https://www.gnu.org/licenses/>.

//go:generate go build
//go:generate go run . -include=gohelp2man.h2m -output=gohelp2man.1 ./gohelp2man

package main

import (
	"bufio"
	"bytes"
	"flag"
	"fmt"
	"io"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"runtime/debug"
	"strconv"
	"strings"
	"time"
)

const (
	Name  = "gohelp2man"
	Usage = `%s generates a man page out of a Go program's -help output.

Go has a simple but very effective "flag" package that can be used to quickly
create CLI applications without any additional dependencies. But this package
cannot generate man pages.

gohelp2man takes inspiration from GNU help2man, and generates a man page from
the -help output of your Go program. It is specifically designed to recognise
the help message generated by the "flag" package.

It is a great match with "go get -tool" and "go generate"!

Usage: %s [OPTION]... EXECUTABLE
`

	RegexSection = `^\[([^]]+)\]\s*$`
	RegexUsage   = `[Uu]sage(:| of) (?U:(.*)):?$`
	RegexUsage2  = `^((\t|\s+or: )(.*)|  ([^-].*))$`
	RegexHeader  = `^(\w.*):\s*$`
	RegexFlag    = `^  -((\w)\t(.*)|([-\w]+) (.+)|[-\w]+)$`
	RegexFUsage  = `^  [^-].*$`
)

var (
	l            = log.New(os.Stderr, Name+": ", 0)
	regexSection = regexp.MustCompile(RegexSection)
	regexUsage   = regexp.MustCompile(RegexUsage)
	regexUsage2  = regexp.MustCompile(RegexUsage2)
	regexHeader  = regexp.MustCompile(RegexHeader)
	regexFlag    = regexp.MustCompile(RegexFlag)
	regexFUsage  = regexp.MustCompile(RegexFUsage)
)

var KnownSections = [12]string{
	"NAME",
	"SYNOPSIS",
	"DESCRIPTION",
	"OPTIONS",
	// Other
	"ENVIRONMENT",
	"FILES",
	"EXAMPLES",
	"AUTHOR",
	"REPORTING BUGS",
	"COPYRIGHT",
	"SEE ALSO",
}

func findKnownSection(s string) (title string, found bool) {
	title = strings.ToUpper(s)
	switch title {
	case "OPTIONS", "FLAGS":
		title = "OPTIONS"
		fallthrough
	case "NAME",
		"SYNOPSIS",
		"DESCRIPTION",
		"ENVIRONMENT",
		"FILES",
		"EXAMPLES",
		"AUTHOR",
		"REPORTING BUGS",
		"COPYRIGHT",
		"SEE ALSO":
		found = true
	}
	return
}

type Section struct {
	Title string
	Text  string
}

func (s *Section) String() string {
	return fmt.Sprintf("{%q %q}", s.Title, s.Text)
}

type Flag struct {
	Name  string
	Arg   string
	Usage string
}

func (f *Flag) String() string {
	return fmt.Sprintf("-%s %q: %s", f.Name, f.Arg, f.Usage)
}

type Help struct {
	Usage    string
	Flags    []*Flag
	Sections map[string]*Section

	scanner *bufio.Scanner
}

func NewHelp(help io.Reader) *Help {
	return &Help{
		Sections: make(map[string]*Section),
		scanner:  bufio.NewScanner(help),
	}
}

// parseUsage parses synopsis lines from the internal reader. It will continue
// until the current line does not look like a synopsis/usage string, leaving
// the current line to be parsed.
func (h *Help) parseUsage() {
	var text strings.Builder
	line := h.scanner.Bytes()
	m := regexUsage.FindSubmatch(line)
	if m != nil {
		if bytes.IndexRune(m[2], ' ') != -1 {
			text.Write(m[2])
		}
		for h.scanner.Scan() {
			m = regexUsage2.FindSubmatch(h.scanner.Bytes())
			if m != nil {
				text.WriteString("\n")
				text.Write(bytes.TrimSpace(m[3]))
				text.Write(bytes.TrimSpace(m[4]))
			} else {
				break
			}
		}
		h.Usage = strings.TrimSpace(text.String())
	}
}

func (h *Help) parseHeader() (header string, found bool) {
	line := h.scanner.Text()
	m := regexHeader.FindStringSubmatch(line)
	if m != nil {
		return m[1], true
	}
	return "", false
}

// parseFlag parses a flag in the current line. If returns (nil, false) if the
// line does not match.
func (h *Help) parseFlag() (f *Flag, found bool) {
	line := h.scanner.Text()
	m := regexFlag.FindStringSubmatch(line)
	found = m != nil
	if found {
		f = new(Flag)
		switch {
		case m[2] != "": // short flag
			f.Name = m[2]
			f.Usage = m[3]
			return
		case m[4] != "": // flag with arg
			f.Name = m[4]
			f.Arg = m[5]
		default:
			f.Name = m[1]
		}
	}
	return
}

// parseFlags parses flags from the internal reader. It will continue until
// the current line does not look like a flag or a flag description, leaving
// the current line to be parsed.
func (h *Help) parseFlags() {
	// TODO: group together flags with the same description
	// TODO: maybe group together short flag without description
	//       and the only flag that start with this letter?
	for {
		if f, found := h.parseFlag(); found {
			var text strings.Builder
			if f.Usage != "" {
				text.WriteString(f.Usage)
			}
			h.Flags = append(h.Flags, f)
			for h.scanner.Scan() {
				line := h.scanner.Text()
				if regexFUsage.MatchString(line) {
					text.WriteString(" ")
					text.WriteString(strings.TrimSpace(line))
				} else {
					break
				}
			}
			f.Usage = strings.TrimSpace(text.String())
		} else {
			break
		}
	}
}

// parse parses the help message from the internal reader.
func (h *Help) parse() error {
	var s *Section = &Section{Title: "DESCRIPTION"}
	var text strings.Builder
	finaliseSection := func() {
		s.Text = strings.TrimSpace(text.String())
		if s.Text != "" {
			h.Sections[s.Title] = s
		}
		text.Reset()
	}

	for h.scanner.Scan() {
		h.parseUsage()
		if hr, found := h.parseHeader(); found {
			if title, found := findKnownSection(hr); found {
				finaliseSection()
				s = &Section{Title: title}
			} else {
				text.WriteString(".SS ")
				text.WriteString(hr)
				text.WriteString(":\n")
			}
			continue
		}
		h.parseFlags()
		text.Write(h.scanner.Bytes())
		text.WriteString("\n")
	}
	finaliseSection()
	return h.scanner.Err()
}

type Include struct {
	Sections      map[string]*Section
	OtherSections []*Section
}

// parseInclude parses an .h2m include file.
func parseInclude(r io.Reader) (*Include, error) {
	i := &Include{Sections: make(map[string]*Section)}

	var s *Section
	var text strings.Builder
	finaliseSection := func() {
		if s != nil {
			s.Text = strings.TrimSpace(text.String())
		}
		text.Reset()
	}

	scanner := bufio.NewScanner(r)
	for scanner.Scan() {
		line := scanner.Text()
		m := regexSection.FindStringSubmatch(line)
		if m != nil {
			finaliseSection()
			title, found := findKnownSection(m[1])
			s = &Section{Title: title}
			if found {
				i.Sections[title] = s
			} else {
				i.OtherSections = append(i.OtherSections, s)
			}
			continue
		}
		text.WriteString(line)
		text.WriteString("\n")
	}
	finaliseSection()
	return i, scanner.Err()
}

// getHelp runs the given exe with the -help flag to return its output.
func getHelp(exe string) ([]byte, error) {
	cmd := exec.Command(exe, "-help")
	out, err := cmd.CombinedOutput()
	if err != nil {
		return nil, fmt.Errorf("run %s: %w", cmd, err)
	}
	if len(out) == 0 {
		return nil, fmt.Errorf("run %s: empty output", cmd)
	}
	return out, err
}

// version returns the current version of gohelp2man as found in build info.
func version() string {
	v := "(unknown)"
	info, ok := debug.ReadBuildInfo()
	if ok {
		v = info.Main.Version
	}
	return v
}

// now returns the current time or the value of SOURCE_DATE_EPOCH if defined.
func now() time.Time {
	if epoch := os.Getenv("SOURCE_DATE_EPOCH"); epoch != "" {
		unixEpoch, err := strconv.ParseInt(epoch, 10, 64)
		if err != nil {
			panic("invalid SOURCE_DATE_EPOCH: " + err.Error())
		}
		return time.Unix(unixEpoch, 0)
	} else {
		return time.Now()
	}
}

var escapeReplacer = strings.NewReplacer(
	`-`, `\-`,
	`\`, `\(rs`,
	"\n\n", "\n.PP\n", // TODO: make this more robust maybe using regexp.ReplaceAll
	// TODO: also escape lines starting with "."
)

// e escapes a value to be included as is in a man page.
func e(v any) string {
	return escapeReplacer.Replace(fmt.Sprint(v))
}

// efprint is like [fmt.Fprint] with all args escaped with [e].
func efprint(w io.Writer, args ...any) (int, error) {
	return escapeReplacer.WriteString(w, fmt.Sprint(args...))
}

// efprint is like [fmt.Fprintln] with all args escaped with [e].
func efprintln(w io.Writer, args ...any) (int, error) {
	return escapeReplacer.WriteString(w, fmt.Sprintln(args...))
}

// efprint is like [fmt.Fprintf] with all args escaped with [e].
func efprintf(w io.Writer, format string, args ...any) (int, error) {
	eargs := make([]any, len(args))
	for i, arg := range args {
		eargs[i] = e(arg)
	}
	return fmt.Fprintf(w, format, eargs...)
}

// writeSynopsis formats a synopsis line by writing the command name in bold
// and the arguments inside brackets in italic.
func writeSynopsis(w io.Writer, synopsis string) {
	name, rest, found := strings.Cut(strings.TrimSpace(synopsis), " ")
	if !found {
		efprintf(w, "\\fB%s\\fR", name)
		return
	}
	splits := strings.Split(rest, "\n"+name+" ")
	for i, args := range splits {
		if i != 0 {
			fmt.Fprint(w, ".br\n")
		}
		efprintf(w, "\\fB%s\\fR ", name)
		for {
			lBracket := strings.Index(args, "[")
			if lBracket == -1 {
				efprint(w, args)
				break
			}
			efprint(w, args[:lBracket])
			args = args[lBracket:]
			rBracket := strings.Index(args, "]")
			if rBracket == -1 {
				efprint(w, args)
				break
			}
			fmt.Fprint(w, "[")
			efprintf(w, "\\fI%s\\fR", args[1:rBracket])
			fmt.Fprint(w, "]")
			args = args[rBracket+1:]
		}
		fmt.Fprintln(w)
	}
}

// writeKnownSection writes the section with given title in w if it is present
// at least in i or h. It withHeader is true and the section is found, then
// the title of this section it prependend to the section's text.
//
// The text from i is written first, and if the section is present in both i
// and h, then they will be in different paragraphs.
func writeKnownSection(w io.Writer, i *Include, h *Help, title string, withHeader bool) {
	si, foundi := i.Sections[title]
	sh, foundh := h.Sections[title]
	if !foundi && !foundh {
		return
	}
	if withHeader {
		fmt.Fprintf(w, ".SH %s\n", title)
	}
	if foundi {
		fmt.Fprintln(w, si.Text)
		if foundh {
			fmt.Fprintln(w, ".PP")
		}
	}
	if foundh {
		efprintln(w, sh.Text)
	}
}

func main() {
	cli := flag.NewFlagSet(Name, flag.ExitOnError)
	cli.Usage = func() {
		fmt.Fprintf(cli.Output(), Usage, Name, Name)
		cli.PrintDefaults()
	}
	// TODO: add some more flags from help2man, especially:
	//       -manual, -opt-include and -version-string
	var (
		flagHelp    bool
		flagInclude string
		flagName    string
		flagOutput  string
		flagSection uint
		flagVersion bool
	)
	cli.BoolVar(&flagHelp, "help", false, "Show this help and exit.")
	cli.StringVar(&flagInclude, "include", "", "Include material from `FILE`.")
	cli.StringVar(&flagName, "name", "", "Description for the NAME paragraph.")
	cli.StringVar(&flagOutput, "output", "", "Send output to `FILE` rather than stdout.")
	cli.UintVar(&flagSection, "section", 1, "Section number for manual page (1, 6, 8).")
	cli.BoolVar(&flagVersion, "version", false, "Show version number and exit.")
	cli.Parse(os.Args[1:])

	if flagHelp {
		cli.Usage()
		os.Exit(0)
	}

	if flagVersion {
		fmt.Println(Name, version())
		os.Exit(0)
	}

	exe := cli.Arg(0)
	if exe == "" {
		l.Print("missing argument: executable")
		cli.Usage()
		os.Exit(2)
	}

	include := &Include{}
	if flagInclude != "" {
		var err error
		f, err := os.Open(flagInclude)
		if err != nil {
			l.Fatalln("include file:", err)
		}
		include, err = parseInclude(bufio.NewReader(f))
		if err != nil {
			l.Fatalln("parse include:", err)
		}
	}

	out, err := getHelp(exe)
	if err != nil {
		l.Fatalln("get help:", err)
	}
	help := NewHelp(bytes.NewBuffer(out))
	err = help.parse()
	if err != nil {
		l.Fatalln("parse output:", err)
	}

	name := filepath.Base(exe)
	description := "manual page for " + name
	if s, found := include.Sections["NAME"]; found {
		n, d, ok := strings.Cut(s.Text, " - ")
		if !ok {
			l.Fatalf("invalid [name] section %q", s.Text)
		}
		if i := strings.IndexAny(n, " \t\n\r"); i != -1 {
			l.Fatalf("illegal character %q in program name: %q", n[i], n)
		}
		name, description = n, d
	}
	if flagName != "" {
		description = flagName
	}

	var w io.Writer
	if flagOutput != "" {
		file, err := os.Create(flagOutput)
		if err != nil {
			l.Fatalln("create output file:", err)
		}
		w = bufio.NewWriter(file)
	} else {
		w = os.Stdout
	}
	b := bufio.NewWriter(w)

	// Write generator comment
	fmt.Fprintf(b, ".\\\" Generated by %s %s; DO NOT EDIT.\n", Name, version())

	// Write title
	fmt.Fprintf(b, ".TH %s %v %q %q\n",
		e(strings.ToUpper(name)), flagSection, now().Format("2006-01-02"), name,
	)

	// Write NAME section
	efprintf(b, ".SH NAME\n%v \\- %v\n", name, description)

	// Write SYNOPSIS section
	fmt.Fprintln(b, ".SH SYNOPSIS")
	if s, found := include.Sections["SYNOPSIS"]; found {
		fmt.Fprintln(b, s.Text)
	} else if help.Usage != "" {
		writeSynopsis(b, help.Usage)
	} else {
		efprintf(b, "\\fB%s\\fR [\\fIOPTION\\fR]... [\\fIARGUMENT\\fR]...\n", name)
	}

	// Write DESCRIPTION section
	writeKnownSection(b, include, help, "DESCRIPTION", true)

	// Write OPTIONS section
	fmt.Fprintf(b, ".SH %s\n", "OPTIONS")
	writeKnownSection(b, include, help, "OPTIONS", false)
	for _, f := range help.Flags {
		if f.Arg != "" {
			efprintf(b, ".TP\n\\fB\\-%s\\fR %s\n", f.Name, f.Arg)
		} else {
			efprintf(b, ".TP\n\\fB\\-%s\\fR\n", f.Name)
		}
		efprintln(b, f.Usage)
	}

	// Write other included sections
	for _, s := range include.OtherSections {
		fmt.Fprintf(b, ".SH %s\n%s\n", s.Title, s.Text)
	}

	// Write last known sections
	for _, title := range KnownSections[4:] {
		writeKnownSection(b, include, help, title, true)
	}

	// Print man page
	b.Flush()
}
